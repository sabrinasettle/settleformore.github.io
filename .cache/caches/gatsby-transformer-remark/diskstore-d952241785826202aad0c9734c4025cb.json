{"expireTime":9007200867977581000,"key":"transformer-remark-markdown-html-702278141c020f7c64ff1e7f2950c532-gatsby-remark-giphygatsby-remark-instagram-embedgatsby-remark-responsive-iframe-","val":"<p>So algothrims, fun right? Actually before this prep I found this part of Computer Science to be \"beyond\" me. I found it confusing and I thought I was too right brained to understand it.</p>\n<p>But really I had people who were not experienced enough on the subject teach me these concepts. This means that I was missing key aspects.</p>\n<p>I wanna start by defining something important.</p>\n<h3>Algothrim</h3>\n<p>/ˈalɡərɪð(ə)m/\n<em>noun</em>\na process or set of rules to be followed in calculations or other problem-solving operations, especially by a computer.</p>\n<p>This means that a coding problem that asks you to find how many pages are in a chapter has an algothrim. Or a method to update users in a database has an algothrim.</p>\n<p>It's as simple as that. </p>\n<p><a href=\"https://imgflip.com/i/4xn7wz\"><img src=\"https://i.imgflip.com/4xn7wz.jpg\" title=\"made at imgflip.com\"/></a></p>\n<p>All this code is public and can be found at <a href=\"https://repl.it/@vbb123/Algorithms\">https://repl.it/@vbb123/Algorithms</a>.</p>\n<h2>Binary Search</h2>\n<p>This search only works on a previously sorted array. And the search happens by dividing the array in two (hence the \"binary\") by creating a left and a right of a \"mid\" or median. Using a target value that you are searching for the algothrim searches only one, left or right, for the target.</p>\n<p>A very simple implentation would be:</p>\n<pre><code>def binarySearch(arr, target)\n  arr.bsearch {|e| e &#x3C;=> target}\nend\n</code></pre>\n<p>Breakdown:\nI used bsearch with a block with a spaceship operator.</p>\n<p>A note about Spaceship Operators:\nUsed independently, it will return 1, 0, or -1 depending if the left value is greater than, equal or less than the value of the right.</p>\n<p>So heres a more complex version:</p>\n<pre><code>def binarySearch(arr, target)\n    left_most = 0\n    right_most = arr.length - 1\n  \n    while left_most &#x3C;= right_most\n        mid = (left_most + right_most) / 2\n        # p \"value: #{arr[mid]} mid: #{mid}\"\n        if arr[mid] == target\n            return \"index of #{target} is #{mid}\"\n        elsif arr[mid] > target\n        # makes the right_most position one less than the mid \n            right_most = mid - 1\n        elsif arr[mid] &#x3C; target\n            left_most = mid + 1\n        else\n            return \"#{target} isnt in the array\"\n    end\nend\n</code></pre>\n<h3>O notation</h3>\n<ul>\n<li>Best</li>\n<li>Worst</li>\n<li>Average?</li>\n</ul>\n<h2>Quick Sort</h2>\n<pre><code>def quicksort(*arr)\n    # edge case\n    return arr if arr.length &#x3C;= 1\n\n    # find the pivot\n    pivot = arr.delete_at(rand(arr.size))\n    left, right = arr.partition {|x| x &#x3C; pivot}\n    return *quicksort(*left), pivot, *quicksort(*right)\nend\n</code></pre>\n<p>Break down:</p>\n<pre><code>    *arr\n</code></pre>\n<p>This parameter opens the method to using multiple parameters without defining the specific parameters.</p>\n<pre><code>    pivot = arr.delete_at(rand(arr.size))\n</code></pre>\n<p>Quicksort relies on a pivot, which can be chosen 3 ways: </p>\n<ol>\n<li>Completely random (which is the way I use it, I will include the two other ways later)</li>\n<li>Choosing a median of three, choosing three random elements. Then pick a median of those three. Provides a more exact median for the main array.</li>\n<li>Choose the last element in the array.</li>\n</ol>\n<pre><code>left, right = arr.partition {|x| x &#x3C; pivot}\n</code></pre>\n<p><a href=\"https://apidock.com/ruby/Enumerable/partition\">https://apidock.com/ruby/Enumerable/partition</a></p>\n<pre><code>    return *quicksort(*left), pivot, *quicksort(*right)\n</code></pre>\n<p>This is the recrusive part of the algothrim. We have the function twice for both left and right</p>\n<h3>O notation</h3>\n<ul>\n<li>Best - O(n log n)</li>\n<li>Worst - O(n²)</li>\n<li>Average?</li>\n</ul>\n<h2>Merge Sort</h2>\n<p>A very simple implentation would be:</p>\n<pre><code>    arr.sort!\n</code></pre>\n<p>But that doesn't teach you anything because the Ruby functions hide what happens behind the scenes.</p>\n<p>So we take a hints from the Binary Search and Quick Sort and we will divide the array and then recursively sort the array.</p>\n<pre><code>def mergeSort(arr)\n  return arr if arr.size &#x3C;= 1\n  mid = (arr.size.to_f / 2).ceil\n  # seprates the arr into two distict arrays\n  # iterates through with the decrese on mid in the left array\n  # also the recrusion\n  left = mergeSort(arr[0..mid - 1])\n  right = mergeSort(arr[mid..arr.size])\n  merge(left, right)\nend\n\ndef merge(left, right)\n  left_last = left.size\n  right_last = right.size\n  if left.empty?\n    right\n  elsif right.empty?\n    left\n  elsif left.first &#x3C; right.first\n    # new small Array\n    sa = [left.first]\n    sa + merge(left[1..left_last], right)\n  else\n    sa = [right.first]\n    sa + merge(left, right[1..right_last])\n  end\nend\n</code></pre>\n<h3>O notation</h3>\n<ul>\n<li>Best - O(n log n)</li>\n<li>Worst</li>\n<li>Average?</li>\n</ul>\n<h2>Breadth-First Search (BFS)</h2>\n<p>Explores the edges and nodes on a graph. Useful for finding the shortest path on unweighted graphs</p>\n<p>It starts at an arbitrary node, explores the neighbors of that node then the next level, and the next after that.</p>\n<h3>O notation</h3>\n<ul>\n<li>Best</li>\n<li>Worst</li>\n<li>Average?</li>\n</ul>\n<h2>Depth-First Search</h2>\n<h3>O notation</h3>\n<ul>\n<li>Best</li>\n<li>Worst</li>\n<li>Average?</li>\n</ul>\n<h2>Resources</h2>\n<p><a href=\"https://hired.com/blog/candidates/technical-onsite-interview-guide/?utm_source=customerio&#x26;utm_medium=email&#x26;utm_campaign=(b2c)(en_7_master)(c_rejected_SWE-nurture\">https://hired.com/blog/candidates/technical-onsite-interview-guide/?utm_source=customerio&#x26;utm_medium=email&#x26;utm_campaign=(b2c)(en_7_master)(c_rejected_SWE-nurture</a>)\n<a href=\"https://hired.com/blog/candidates/5-ways-to-stand-out-during-your-next-technical-interview/?utm_source=customerio&#x26;utm_medium=email&#x26;utm_campaign=(b2c)(en_7_master)(c_rejected_SWE-nurture\">https://hired.com/blog/candidates/5-ways-to-stand-out-during-your-next-technical-interview/?utm_source=customerio&#x26;utm_medium=email&#x26;utm_campaign=(b2c)(en_7_master)(c_rejected_SWE-nurture</a>)\n<a href=\"https://www.quora.com/What-should-I-expect-in-a-Software-Engineer-interview-at-Google-and-how-should-I-prepare/answer/Moishe-Lettvin?srid=unsVg\">https://www.quora.com/What-should-I-expect-in-a-Software-Engineer-interview-at-Google-and-how-should-I-prepare/answer/Moishe-Lettvin?srid=unsVg</a></p>\n<p><a href=\"https://stackoverflow.com/questions/65461890/in-ruby-is-it-better-to-receive-array-or-to-duplicate-and-array-inside-a-metho\">https://stackoverflow.com/questions/65461890/in-ruby-is-it-better-to-receive-array-or-to-duplicate-and-array-inside-a-metho</a></p>\n<p><a href=\"https://coderwall.com/p/qfh2ua/ruby-tricks-to-make-your-code-more-fun-and-less-readable\">https://coderwall.com/p/qfh2ua/ruby-tricks-to-make-your-code-more-fun-and-less-readable</a></p>\n<p><a href=\"https://coderwall.com/p/vue87q/ruby-operators-names-aliases-and-uses\">https://coderwall.com/p/vue87q/ruby-operators-names-aliases-and-uses</a></p>\n<p><a href=\"https://www.rubydoc.info/stdlib/core/Array:bsearch\">https://www.rubydoc.info/stdlib/core/Array:bsearch</a></p>\n<h3>Code Snippets that helped</h3>\n<p><a href=\"https://gist.github.com/JonathanSpeek/225cd0c05f66ffdd4f52bef77135881a\">https://gist.github.com/JonathanSpeek/225cd0c05f66ffdd4f52bef77135881a</a>\n<a href=\"https://stackoverflow.com/questions/32210399/binary-search-ruby\">https://stackoverflow.com/questions/32210399/binary-search-ruby</a></p>"}